plugins {
    id 'org.springframework.boot'
}

dependencies {
    // ë‚´ë¶€ ëª¨ë“ˆ ì˜ì¡´ì„± (ìµœì†Œí™”)
    implementation(project(':edukit-core')) {
        exclude group: 'io.jsonwebtoken'
        exclude group: 'org.mindrot', module: 'jbcrypt'
    }

    implementation(project(':edukit-external')) {
        exclude group: 'org.springframework.ai'
        exclude group: 'software.amazon.awssdk', module: 's3'
        exclude group: 'io.github.resilience4j'
        exclude group: 'org.springframework.boot', module: 'spring-boot-starter-data-redis'
        exclude group: 'io.projectreactor.netty', module: 'reactor-netty-http'
    }

    // AWS Lambda í•µì‹¬ (ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ í•¨ê»˜ íŒ¨í‚¤ì§•)
    implementation 'com.amazonaws:aws-lambda-java-core:1.3.0'
    implementation 'com.amazonaws:aws-lambda-java-events:3.16.1'
}

// Layerë³„ ì˜ì¡´ì„± êµ¬ì„± ì •ì˜
configurations {
    // Spring Framework Layer
    springLayer {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom implementation
    }

    // Database/Persistence Layer
    databaseLayer {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom implementation
    }

    // External Integration Layer (AWS, etc.)
    externalLayer {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom implementation
    }

    // Utilities Layer (JSON, Logging, etc.)
    utilsLayer {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom implementation
    }
}

// Layerë³„ ì˜ì¡´ì„± ë¶„ë¥˜ í•¨ìˆ˜
def classifyDependency = { fileName ->
    if (fileName.startsWith('edukit-') || fileName.contains('aws-lambda-java-')) {
        return 'APPLICATION' // ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ í•¨ê»˜ íŒ¨í‚¤ì§•
    } else if (fileName.contains('spring-') || fileName.contains('springframework')) {
        return 'SPRING'
    } else if (fileName.contains('mysql') || fileName.contains('hibernate') ||
            fileName.contains('jpa') || fileName.contains('jdbc') ||
            fileName.contains('datasource') || fileName.contains('transaction')) {
        return 'DATABASE'
    } else if (fileName.contains('aws-') && !fileName.contains('lambda') ||
            fileName.contains('ses') || fileName.contains('s3') ||
            fileName.contains('thymeleaf')) {
        return 'EXTERNAL'
    } else if (fileName.contains('jackson') || fileName.contains('logback') ||
            fileName.contains('slf4j') || fileName.contains('logstash') ||
            fileName.contains('json')) {
        return 'UTILS'
    } else {
        return 'OTHER'
    }
}

// Spring Framework Layer ìƒì„±
tasks.register('buildSpringLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/spring/java/lib'

    include { details ->
        def category = classifyDependency(details.file.name)
        return category == 'SPRING'
    }

    doFirst {
        delete 'build/layers/spring'
        mkdir 'build/layers/spring/java/lib'
    }

    doLast {
        def layerSize = calculateLayerSize('build/layers/spring')
        println "ðŸ“¦ Spring Layer: ${String.format('%.2f', layerSize)} MB"
    }
}

// Database Layer ìƒì„±
tasks.register('buildDatabaseLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/database/java/lib'

    include { details ->
        def category = classifyDependency(details.file.name)
        return category == 'DATABASE'
    }

    doFirst {
        delete 'build/layers/database'
        mkdir 'build/layers/database/java/lib'
    }

    doLast {
        def layerSize = calculateLayerSize('build/layers/database')
        println "ðŸ“¦ Database Layer: ${String.format('%.2f', layerSize)} MB"
    }
}

// External Integration Layer ìƒì„±
tasks.register('buildExternalLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/external/java/lib'

    include { details ->
        def category = classifyDependency(details.file.name)
        return category == 'EXTERNAL'
    }

    doFirst {
        delete 'build/layers/external'
        mkdir 'build/layers/external/java/lib'
    }

    doLast {
        def layerSize = calculateLayerSize('build/layers/external')
        println "ðŸ“¦ External Layer: ${String.format('%.2f', layerSize)} MB"
    }
}

// Utils Layer ìƒì„±
tasks.register('buildUtilsLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/utils/java/lib'

    include { details ->
        def category = classifyDependency(details.file.name)
        return category == 'UTILS'
    }

    doFirst {
        delete 'build/layers/utils'
        mkdir 'build/layers/utils/java/lib'
    }

    doLast {
        def layerSize = calculateLayerSize('build/layers/utils')
        println "ðŸ“¦ Utils Layer: ${String.format('%.2f', layerSize)} MB"
    }
}

// ëª¨ë“  Layer ë¹Œë“œ
tasks.register('buildAllLayers') {
    dependsOn buildSpringLayer, buildDatabaseLayer, buildExternalLayer, buildUtilsLayer

    doLast {
        println "\n=== Layer ë¹Œë“œ ì™„ë£Œ ìš”ì•½ ==="
        ['spring', 'database', 'external', 'utils'].each { layerName ->
            def layerSize = calculateLayerSize("build/layers/${layerName}")
            printf "%-12s: %8.2f MB%n", layerName.toUpperCase(), layerSize
        }

        def totalSize = ['spring', 'database', 'external', 'utils'].sum { layerName ->
            calculateLayerSize("build/layers/${layerName}")
        }
        printf "%-12s: %8.2f MB%n", "TOTAL", totalSize

        if (totalSize > 250) {
            logger.warn "âš ï¸ ì „ì²´ Layer í¬ê¸°ê°€ 250MBì— ê·¼ì ‘í–ˆìŠµë‹ˆë‹¤. ì¶”ê°€ ìµœì í™”ë¥¼ ê³ ë ¤í•˜ì„¸ìš”."
        }
    }
}

// Layer ZIP íŒŒì¼ë“¤ ìƒì„±
tasks.register('buildSpringLayerZip', Zip) {
    dependsOn buildSpringLayer
    archiveFileName = 'spring-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/spring'
}

tasks.register('buildDatabaseLayerZip', Zip) {
    dependsOn buildDatabaseLayer
    archiveFileName = 'database-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/database'
}

tasks.register('buildExternalLayerZip', Zip) {
    dependsOn buildExternalLayer
    archiveFileName = 'external-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/external'
}

tasks.register('buildUtilsLayerZip', Zip) {
    dependsOn buildUtilsLayer
    archiveFileName = 'utils-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/utils'
}

tasks.register('buildAllLayerZips') {
    dependsOn buildSpringLayerZip, buildDatabaseLayerZip, buildExternalLayerZip, buildUtilsLayerZip
}

// ë‚´ë¶€ ëª¨ë“ˆë“¤ì„ ë³„ë„ ë””ë ‰í† ë¦¬ë¡œ ë³µì‚¬
tasks.register('buildInternalModules', Copy) {
    dependsOn ':edukit-core:jar', ':edukit-external:jar', ':edukit-common:jar'

    from project(':edukit-core').jar.archiveFile
    from project(':edukit-external').jar.archiveFile
    from project(':edukit-common').jar.archiveFile
    into 'build/internal-modules/lib'

    doFirst {
        delete 'build/internal-modules'
        mkdir 'build/internal-modules/lib'
    }
}

// ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ìš© thin JAR ìƒì„± (Layer ì˜ì¡´ì„± ì œì™¸)
jar {
    archiveBaseName = 'edukit-batch-app'
    archiveVersion = project.version
    enabled = true

    manifest {
        attributes(
                'Main-Class': 'com.edukit.batch.handler.TeacherVerificationHandler',
                'Implementation-Title': 'EduKit Batch Lambda Function',
                'Implementation-Version': project.version,
                'Lambda-Compatible': 'true'
        )
    }

    doLast {
        def jarFile = archiveFile.get().asFile
        def sizeInMB = jarFile.length() / (1024 * 1024)
        println "ðŸ“¦ Application JAR: ${String.format('%.2f', sizeInMB)} MB"
    }
}

// Lambda ë°°í¬ìš© ZIP ìƒì„± (ì• í”Œë¦¬ì¼€ì´ì…˜ + ë‚´ë¶€ ëª¨ë“ˆ + Lambda ëŸ°íƒ€ìž„)
tasks.register('buildLambdaFunctionZip', Zip) {
    dependsOn jar, buildInternalModules
    archiveFileName = 'lambda-function.zip'
    destinationDirectory = file('build/distributions')

    // ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ JAR
    from jar.archiveFile

    // ë‚´ë¶€ ëª¨ë“ˆ JARë“¤
    from('build/internal-modules') {
        into 'lib'
    }

    // AWS Lambda ëŸ°íƒ€ìž„ë§Œ í¬í•¨ (ë‚˜ë¨¸ì§€ëŠ” Layerì—ì„œ ì œê³µ)
    into('lib') {
        from configurations.runtimeClasspath
        include '**/aws-lambda-java-*.jar'
    }

    doLast {
        def zipFile = archiveFile.get().asFile
        def sizeInMB = zipFile.length() / (1024 * 1024)
        println "ðŸ“¦ Lambda Function ZIP: ${String.format('%.2f', sizeInMB)} MB"

        if (sizeInMB > 50) {
            logger.warn "âš ï¸ Function ZIPì´ 50MBë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤: ${sizeInMB}MB"
        } else {
            println "âœ… Function ZIP í¬ê¸° OK: ${sizeInMB}MB"
        }
    }
}

// ì „ì²´ ë¹Œë“œ íƒœìŠ¤í¬
tasks.register('buildLambda') {
    dependsOn buildLambdaFunctionZip, buildAllLayerZips

    doLast {
        println """
========================================
ðŸš€ ë‹¤ì¤‘ Layer Lambda ë¹Œë“œ ì™„ë£Œ!
========================================
ðŸ“ ë¹Œë“œ ê²°ê³¼ë¬¼:
  Function ZIP: build/distributions/lambda-function.zip
  
  Layer ZIPs:
  - build/distributions/layers/spring-layer.zip
  - build/distributions/layers/database-layer.zip  
  - build/distributions/layers/external-layer.zip
  - build/distributions/layers/utils-layer.zip

ðŸ“‹ ë°°í¬ ìˆœì„œ:
  1. ëª¨ë“  Layer ZIP ë°°í¬
  2. Lambda Function ìƒì„±/ì—…ë°ì´íŠ¸ (ëª¨ë“  Layer ì—°ê²°)
  3. í•¨ìˆ˜ ì‹¤í–‰

ðŸ”„ ìž¬ì‚¬ìš© ê°€ëŠ¥í•œ Layer:
  - Spring Layer: ë‹¤ë¥¸ Spring Lambda í•¨ìˆ˜ì—ì„œ ìž¬ì‚¬ìš©
  - Utils Layer: ë¡œê¹…/JSON ì²˜ë¦¬í•˜ëŠ” ëª¨ë“  í•¨ìˆ˜ì—ì„œ ìž¬ì‚¬ìš©
  - Database Layer: DB ì•¡ì„¸ìŠ¤í•˜ëŠ” ëª¨ë“  í•¨ìˆ˜ì—ì„œ ìž¬ì‚¬ìš©
  - External Layer: AWS ì„œë¹„ìŠ¤ ì—°ë™í•˜ëŠ” í•¨ìˆ˜ì—ì„œ ìž¬ì‚¬ìš©
========================================
        """
    }
}

// ë¹Œë“œ ì •ë¦¬ íƒœìŠ¤í¬
tasks.register('cleanLambda') {
    doLast {
        delete 'build/layers'
        delete 'build/internal-modules'
        delete 'build/distributions'
    }
}

clean.dependsOn cleanLambda

// Spring Boot JARëŠ” ë¹„í™œì„±í™”
bootJar {
    enabled = false
}

// ì˜ì¡´ì„± ë¶„ì„ íƒœìŠ¤í¬ (Layer ë¶„ë¥˜ í™•ì¸ìš©)
tasks.register('analyzeDependencies') {
    doLast {
        def categories = [:]

        println "=== ì˜ì¡´ì„± Layer ë¶„ë¥˜ ë¶„ì„ ==="
        configurations.runtimeClasspath.files.each { file ->
            def sizeInMB = file.length() / (1024 * 1024)
            def category = classifyDependency(file.name)

            if (!categories.containsKey(category)) {
                categories[category] = []
            }
            categories[category] << [name: file.name, size: sizeInMB]
        }

        categories.each { category, files ->
            def totalSize = files.sum { it.size }
            println "\nðŸ“¦ ${category} Layer (${String.format('%.2f', totalSize)} MB):"
            files.sort { -it.size }.take(10).each { file ->
                printf "  %-8.2f MB  %s%n", file.size, file.name
            }
            if (files.size() > 10) {
                println "  ... and ${files.size() - 10} more files"
            }
        }

        def layerSizes = [
                'SPRING'  : categories['SPRING']?.sum { it.size } ?: 0,
                'DATABASE': categories['DATABASE']?.sum { it.size } ?: 0,
                'EXTERNAL': categories['EXTERNAL']?.sum { it.size } ?: 0,
                'UTILS'   : categories['UTILS']?.sum { it.size } ?: 0
        ]

        println "\nðŸ“Š ì˜ˆìƒ Layer í¬ê¸°:"
        layerSizes.each { name, size ->
            printf "%-12s: %8.2f MB%n", name, size
        }
        printf "%-12s: %8.2f MB%n", "TOTAL LAYERS", layerSizes.values().sum()
    }
}

// Layer í¬ê¸° ê³„ì‚° í—¬í¼ í•¨ìˆ˜
def calculateLayerSize(String layerPath) {
    def layerSize = 0
    def layerDir = file(layerPath)
    if (layerDir.exists()) {
        layerDir.eachFileRecurse { file ->
            if (file.isFile()) layerSize += file.length()
        }
    }
    return layerSize / (1024 * 1024) // MB ë‹¨ìœ„ë¡œ ë°˜í™˜
}
