plugins {
    id 'org.springframework.boot'
}

dependencies {
    implementation(project(':edukit-core')) {
        exclude group: 'io.jsonwebtoken'
        exclude group: 'org.mindrot', module: 'jbcrypt'
    }

    implementation(project(':edukit-external')) {
        exclude group: 'org.springframework.ai'
        exclude group: 'software.amazon.awssdk', module: 's3'
        exclude group: 'io.github.resilience4j'
        exclude group: 'org.springframework.boot', module: 'spring-boot-starter-data-redis'
        exclude group: 'io.projectreactor.netty', module: 'reactor-netty-http'
    }

    // AWS Lambda
    implementation 'com.amazonaws:aws-lambda-java-core:1.3.0'
    implementation 'com.amazonaws:aws-lambda-java-events:3.16.1'

    // Logging for CloudWatch
    implementation 'net.logstash.logback:logstash-logback-encoder:8.0'

    // MySQL Connector
    runtimeOnly 'com.mysql:mysql-connector-j'
}

// ì˜ì¡´ì„± ê·¸ëž˜í”„ ê¸°ë°˜ Layer ë¶„ë¥˜ í•¨ìˆ˜ (ê³„ì¸µì  êµ¬ì¡°)
def classifyDependency = { fileName ->
    // 1. APPLICATION: ìš°ë¦¬ ëª¨ë“ˆê³¼ Lambda ëŸ°íƒ€ìž„, MySQL ë“œë¼ì´ë²„ (ìµœìƒìœ„)
    if (fileName.startsWith('edukit-') ||
            fileName.contains('aws-lambda-java-') ||
            fileName.contains('mysql-connector')) {
        return 'APPLICATION'
    }
    // 2. EXTERNAL_LAYER: External ëª¨ë“ˆì´ ì§ì ‘ ì˜ì¡´í•˜ëŠ” ê²ƒë“¤
    else if (fileName.contains('aws-') && !fileName.contains('lambda') ||
            fileName.contains('ses') ||
            fileName.contains('s3') ||
            fileName.contains('sdk-core') ||
            fileName.contains('apache-client') ||
            fileName.contains('jmespath')) {  // mysql-connector ì œê±°
        return 'EXTERNAL_LAYER'
    }
    // 3. CORE_LAYER: Spring Boot, JPA/Hibernate ë“± Coreê°€ ì§ì ‘ ì˜ì¡´í•˜ëŠ” ê²ƒë“¤
    else if (fileName.contains('spring-') || fileName.contains('hibernate') || fileName.contains('aspectj') || fileName.contains('byte-buddy') || fileName.contains('jpa') || fileName.contains('jdbc') || fileName.contains('logstash')) {
        return 'CORE_LAYER'
    }
    // 4. BASE_LAYER: ìµœí•˜ë‹¨ ê³µí†µ ì˜ì¡´ì„±ë“¤ (Jackson, Logback, ê¸°íƒ€ ìœ í‹¸)
    else {
        return 'BASE_LAYER'
    }
}

// Base Layer (ìµœí•˜ë‹¨ ê³µí†µ ì˜ì¡´ì„±) ìƒì„±
tasks.register('buildBaseLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/base-layer/java/lib'

    include { details -> classifyDependency(details.file.name) == 'BASE_LAYER'
    }

    doFirst {
        delete 'build/layers/base-layer'
        mkdir 'build/layers/base-layer/java/lib'
    }
}

// Core Layer (Spring Framework, JPA/Hibernate) ìƒì„±
tasks.register('buildCoreLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/core-layer/java/lib'

    include { details -> classifyDependency(details.file.name) == 'CORE_LAYER'
    }

    doFirst {
        delete 'build/layers/core-layer'
        mkdir 'build/layers/core-layer/java/lib'
    }
}

// External Layer (AWS SDK, MySQL ë“±) ìƒì„±  
tasks.register('buildExternalLayer', Copy) {
    from configurations.runtimeClasspath
    into 'build/layers/external-layer/java/lib'

    include { details -> classifyDependency(details.file.name) == 'EXTERNAL_LAYER'
    }

    doFirst {
        delete 'build/layers/external-layer'
        mkdir 'build/layers/external-layer/java/lib'
    }
}

// ëª¨ë“  Layer ë¹Œë“œ (ì˜ì¡´ì„± ìˆœì„œëŒ€ë¡œ: Base -> Core -> External)
tasks.register('buildAllLayers') {
    dependsOn buildBaseLayer, buildCoreLayer, buildExternalLayer
}

// Layer ZIP íŒŒì¼ë“¤ ìƒì„± (ì˜ì¡´ì„± ìˆœì„œëŒ€ë¡œ)
tasks.register('buildBaseLayerZip', Zip) {
    dependsOn buildBaseLayer
    archiveFileName = 'base-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/base-layer'
}

tasks.register('buildCoreLayerZip', Zip) {
    dependsOn buildCoreLayer
    archiveFileName = 'core-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/core-layer'
}

tasks.register('buildExternalLayerZip', Zip) {
    dependsOn buildExternalLayer
    archiveFileName = 'external-layer.zip'
    destinationDirectory = file('build/distributions/layers')
    from 'build/layers/external-layer'
}

tasks.register('buildAllLayerZips') {
    dependsOn buildBaseLayerZip, buildCoreLayerZip, buildExternalLayerZip
}

// ë‚´ë¶€ ëª¨ë“ˆë“¤ì„ ë³„ë„ ë””ë ‰í† ë¦¬ë¡œ ë³µì‚¬
tasks.register('buildInternalModules', Copy) {
    dependsOn ':edukit-core:jar', ':edukit-external:jar', ':edukit-common:jar'

    from project(':edukit-core').jar.archiveFile
    from project(':edukit-external').jar.archiveFile
    from project(':edukit-common').jar.archiveFile
    into 'build/internal-modules/lib'

    doFirst {
        delete 'build/internal-modules'
        mkdir 'build/internal-modules/lib'
    }
}

// ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ìš© thin JAR ìƒì„±
jar {
    archiveVersion = project.version
    enabled = true

    manifest {
        attributes('Main-Class': 'com.edukit.batch.handler.TeacherVerificationLambdaHandler',
                'Implementation-Title': 'EduKit Batch Lambda Function',
                'Implementation-Version': project.version,
                'Lambda-Compatible': 'true')
    }
}

// Lambdaìš© ì• í”Œë¦¬ì¼€ì´ì…˜ JAR ìƒì„± (Layer ì‹œìŠ¤í…œ ì‚¬ìš©)
tasks.register('buildLambdaAppJar', Jar) {
    dependsOn buildInternalModules
    archiveBaseName = 'lambda-app'           // ê³ ì •ëœ íŒŒì¼ëª…
    archiveVersion = ''                      // ë²„ì „ ì œê±°
    archiveClassifier = ''                   // classifier ì œê±°
    destinationDirectory = file('build/distributions')

    // 1. ì• í”Œë¦¬ì¼€ì´ì…˜ í´ëž˜ìŠ¤ë“¤ í¬í•¨
    from sourceSets.main.output

    // 2. ë‚´ë¶€ ëª¨ë“ˆë“¤ì„ ì••ì¶• í•´ì œí•˜ì—¬ í¬í•¨
    from fileTree('build/internal-modules/lib').matching {
        include '**/*.jar'
    }.collect { zipTree(it) }

    // 3. APPLICATIONìœ¼ë¡œ ë¶„ë¥˜ëœ ì˜ì¡´ì„±ë“¤ í¬í•¨ (MySQL ë“œë¼ì´ë²„, AWS Lambda ëŸ°íƒ€ìž„)
    from configurations.runtimeClasspath.findAll { file ->
        classifyDependency(file.name) == 'APPLICATION'
    }.collect { zipTree(it) }

    // ì¤‘ë³µ íŒŒì¼ ì œê±°
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // META-INF ì •ë¦¬
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'

    // ë©”ì¸ í´ëž˜ìŠ¤ ì„¤ì • (Lambdaì—ì„œëŠ” í•¸ë“¤ëŸ¬ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë¶ˆí•„ìš”í•˜ì§€ë§Œ ëª…ì‹œ)
    manifest {
        attributes('Lambda-Handler': 'com.edukit.batch.handler.TeacherVerificationLambdaHandler::handleRequest')
    }
}

// Lambda ë°°í¬ìš© ZIP ìƒì„± (JAR ë‚´ìš©ì„ ì§ì ‘ ì••ì¶• í•´ì œí•˜ì—¬ í¬í•¨)
tasks.register('buildLambdaFunctionZip', Zip) {
    dependsOn buildLambdaAppJar
    archiveFileName = 'lambda-function.zip'
    destinationDirectory = file('build/distributions')

    // JAR íŒŒì¼ì˜ ë‚´ìš©ì„ ì••ì¶• í•´ì œí•˜ì—¬ ZIPì— ì§ì ‘ í¬í•¨
    from zipTree(buildLambdaAppJar.archiveFile)

    // ì¤‘ë³µ íŒŒì¼ ì œê±°
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// ì „ì²´ ë¹Œë“œ íƒœìŠ¤í¬
tasks.register('buildLambda') {
    dependsOn buildLambdaFunctionZip, buildAllLayerZips
}

// ë¹Œë“œ ì •ë¦¬ íƒœìŠ¤í¬
tasks.register('cleanLambda') {
    doLast {
        delete 'build/layers'
        delete 'build/internal-modules'
        delete 'build/distributions'
    }
}

clean.dependsOn cleanLambda

// Spring Boot JARëŠ” ë¹„í™œì„±í™”
bootJar {
    archiveFileName = 'edukit-batch.jar'
    enabled = false
}

// === ë””ë²„ê¹…ìš© íƒœìŠ¤í¬ë“¤ (ê°œë°œ ì‹œì—ë§Œ ì‚¬ìš©) ===

// ì˜ì¡´ì„± ë¶„ì„ íƒœìŠ¤í¬ (ë¡œì»¬ ê°œë°œ ì‹œì—ë§Œ ì‚¬ìš©)
tasks.register('analyzeDependencies') {
    onlyIf { !System.getenv('CI') } // CI í™˜ê²½ì—ì„œëŠ” ì‹¤í–‰í•˜ì§€ ì•ŠìŒ

    doLast {
        def categories = [:]

        println "=== ì˜ì¡´ì„± Layer ë¶„ë¥˜ ë¶„ì„ ==="
        configurations.runtimeClasspath.files.each { file ->
            def sizeInMB = file.length() / (1024 * 1024)
            def category = classifyDependency(file.name)

            if (!categories.containsKey(category)) {
                categories[category] = []
            }
            categories[category] << [name: file.name, size: sizeInMB]
        }

        categories.each { category, files ->
            def totalSize = files.sum { it.size }
            println "\nðŸ“¦ ${category} Layer (${String.format('%.2f', totalSize)} MB):"
            files.sort { -it.size }.take(5).each { file -> printf "  %-8.2f MB  %s%n", file.size, file.name
            }
            if (files.size() > 5) {
                println "  ... and ${files.size() - 5} more files"
            }
        }
    }
}

// Layer í¬ê¸° ê²€ì¦ íƒœìŠ¤í¬ (ë¹Œë“œ ì‹¤íŒ¨ ë°©ì§€ìš©)
tasks.register('validateLayerSizes') {
    dependsOn buildAllLayerZips

    doLast {
        def totalSize = 0
        def oversizedLayers = []

        ['base', 'core', 'external'].each { layerName ->
            def layerZip = file("build/distributions/layers/${layerName}-layer.zip")
            if (layerZip.exists()) {
                def layerSizeMB = layerZip.length() / (1024 * 1024)
                totalSize += layerSizeMB

                println "ðŸ“¦ ${layerName}-layer.zip: ${String.format('%.1f', layerSizeMB)} MB"

                if (layerSizeMB > 250) {
                    oversizedLayers << "${layerName}: ${String.format('%.1f', layerSizeMB)}MB"
                }
            }
        }

        println "ðŸ“Š Total layers size: ${String.format('%.1f', totalSize)} MB"

        if (oversizedLayers) {
            throw new GradleException("Layer size limit exceeded: ${oversizedLayers.join(', ')}")
        }

        if (totalSize > 1000) { // ì „ì²´ 1GB ì´ˆê³¼ ì‹œ ê²½ê³ 
            logger.warn "Total layer size is large: ${String.format('%.1f', totalSize)}MB"
        }
    }
}

buildLambda.finalizedBy validateLayerSizes
